\section{GIT学习笔记}
\subsection{合并两个提交历史}
\begin{itemize}
\item 使用情景: 有时候在开发过程中会由于不同原因会产生很多个本地提交历史:
\begin{messagebox}
commit dc7a92e627975cf7e75b6cccad872eb28a2bb13d
Author: mozhiye <mozhiye@aaa.com>
Date:   Tue Jul 28 20:43:38 2020 +0800

    [br34]: test git;

commit 93da6cc678a253467efa5165a22019e66b538f88
Author: mozhiye <mozhiye@aaa.com>
Date:   Tue Feb 25 17:12:29 2020 +0800

    [BR34]: add br34 cpu;
\end{messagebox}

\item 如果直接\emphasizebox{push}，会造成合并工作增加，如果需要合并这两个提交历史为一个提交， 使用命令：
\begin{commandbox}
 > git rebase -i HEAD~2
\end{commandbox}

\item 执行\emphasizebox{rebase}命令后，会调用\emphasizebox{vim}显示合并信息：

\begin{messagebox}
pick 93da6cc [BR34]: add br34 cpu;
pick dc7a92e [br34]: test git;

# Rebase 995bb83..dc7a92e onto 995bb83 (2 command(s))
#
# Commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup = like "squash", but discard this commit's log message
# x, exec = run command (the rest of the line) using shell
# d, drop = remove commit
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
\end{messagebox}

\item 由注释可以看到，如果希望把最后一个提交\emphasizebox{test git}合并到上一个提交\emphasizebox{add br34 cpu}；需要如下修改：
\begin{messagebox}
pick 93da6cc [BR34]: add br34 cpu;
squash dc7a92e [br34]: test git;
\end{messagebox}

\item 修改后保存退出\emphasizebox{vim}，可以修改合并后的提交信息：
\begin{messagebox}
# This is a combination of 2 commits.
# The first commit's message is:

[BR34]: add br34 cpu;

# This is the 2nd commit message:

[br34]: test git;

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# Date:      Tue Feb 25 17:12:29 2020 +0800
#
# interactive rebase in progress; onto 995bb83
# Last commands done (2 commands done):
#    pick 93da6cc [BR34]: add br34 cpu;
#    squash dc7a92e [br34]: test git;
# No commands remaining.
# You are currently editing a commit while rebasing branch 'master' on '995bb83'.
#
\end{messagebox}

\item 合并后最终的提交信息：
\begin{messagebox}
commit c92db4f8cc0eae1d2d5d76cb5cc1c96dedf6d004
Author: mozhiye <mozhiye@aaa.com>
Date:   Tue Feb 25 17:12:29 2020 +0800

    [BR34]: add br34 cpu;
        
    [br34]: test git;
\end{messagebox}

\end{itemize}


\subsection{git patch 应用}
\begin{itemize}
\item 使用情景: 当某个问题fix后，在本地生成一个提交或多个提交，可以将该提交的修改生成patch文件发给某个同事合并。
\begin{messagebox}
± git st
On branch dev
Your branch is ahead of 'origin/dev' by 2 commits.
  (use "git push" to publish your local commits)

nothing to commit, working tree clean
\end{messagebox}

\begin{messagebox}
commit 358159bc2c426e9294f5e31789a7a92bcd94a922 (HEAD -> dev)
Author: mozhiye <zhiyemo@outlook.com>
Date:   Wed Jul 29 19:00:28 2020 +0800

    [dev]: patch 2;

commit ed9c6864c6a31854c75884d6202be42b391c88a5
Author: mozhiye <zhiyemo@outlook.com>
Date:   Wed Jul 29 17:43:15 2020 +0800

    [dev]: test patch;

\end{messagebox}

\item 把一个提交生成patch，执行命令：
\begin{commandbox}
± git format-patch -1 358159bc2
0001-dev-patch-2.patch
\end{commandbox}

\item 生成patch内容：
\begin{messagebox}
From 358159bc2c426e9294f5e31789a7a92bcd94a922 Mon Sep 17 00:00:00 2001
From: mozhiye <zhiyemo@outlook.com>
Date: Wed, 29 Jul 2020 19:00:28 +0800
Subject: [PATCH] [dev]: patch 2;

---
 git.tex | 1 +
 1 file changed, 1 insertion(+)

diff --git a/git.tex b/git.tex
index 16f8908..e33d146 100644
--- a/git.tex
+++ b/git.tex
@@ -20,6 +20,7 @@
 \graphicspath{{figure/}}
 \usepackage{newenviron}

+\input{001_latex_env/latex_env}
 \input{001_latex_env/latex_env}

 %==========================================
-- 
2.17.1
\end{messagebox}

\item 把\emphasizebox{0001-dev-patch-2.patch}拷到需要打补丁的工程，检查补丁状态，执行命令：
\begin{commandbox}
± git apply --stat 0001-dev-patch-2.patch 
 README.md |    2 ++
 1 file changed, 2 insertions(+)
\end{commandbox}

\item 检查补丁文件是否应用成功：
\begin{commandbox}
± git apply --check 0001-dev-patch-2.patch
\end{commandbox}

\item 打补丁：
\begin{commandbox}
± git am --signoff 0001-dev-patch-2.patch 
Applying: patch 2;
\end{commandbox}

\item 打补丁后结果：
\begin{messagebox}
commit f6d43d9c327f6a5959f42950e03174bcf838c05e (HEAD -> dev)
Author: mozhiye <zhiyemo@outlook.com>
Date:   Wed Jul 29 19:00:28 2020 +0800

    patch 2;
    
    Signed-off-by: mozhiye <zhiyemo@outlook.com>
\end{messagebox}

\item 关于git patch的一些其他命令：
1. 使用git format-patch生成所需要的patch:
当前分支所有超前master的提交：
\begin{messagebox}
git format-patch -M master
\end{messagebox}

某次提交以后的所有patch:
\begin{messagebox}
git format-patch 4e16                --4e16指的是commit名
从根到指定提交的所有patch:
\end{messagebox}
git format-patch                          --root 4e16
某两次提交之间的所有patch:
\begin{messagebox}
git format-patch 365a..4e16      --365a和4e16分别对应两次提交的名称
\end{messagebox}
某次提交（含）之前的几次提交：
\begin{messagebox}
git format-patch –n 07fe             --n指patch数，07fe对应提交的名称
\end{messagebox}
故，单次提交即为：
\begin{messagebox}
git format-patch -1 07fe
\end{messagebox}
git format-patch生成的补丁文件默认从1开始顺序编号，并使用对应提交信息中的第一行作为文件名。如果使用了-- numbered-files选项，则文件名只有编号，不包含提交信息；如果指定了--stdout选项，可指定输出位置，如当所有patch输出到一个文件；可指定-o <dir>指定patch的存放目录；
 
2. 应用patch：
先检查patch文件：
\begin{messagebox}
git apply --stat newpatch.patch
\end{messagebox}
检查能否应用成功：
\begin{messagebox}
git apply --check  newpatch.patch
\end{messagebox}
打补丁：git am --signoff newpatch.patch
(使用-s或--signoff选项，可以commit信息中加入Signed-off-by信息)
添加-s或者--signoff，还可以把自己的名字添加为signed off by信息，作用是注明打patch的人是谁，因为有时打patch的人并不是patch的作者

3. 注意
git apply是一种打patch的命令，其与git am的区别是，git apply并不会将commit message等打上去，打完patch后需要重新git add和git commit，而git am会直接将patch的所有信息打上去，而且不用重新git add和git commit,author也是patch的author而不是打patch的人)

将路径~/patch-set/*.patch 按照先后顺序打上
\begin{messagebox}
git am ~/patch-set/*.patch
\end{messagebox}

当git am失败时，用以将已经在am过程中打上的patch废弃掉(比如有三个patch，打到第三个patch时有冲突，那么这条命令会把打上的前两个patch丢弃掉，返回没有打patch的状态)
\begin{messagebox}
git am --abort
\end{messagebox}

当git am失败，解决完冲突后，这条命令会接着打patch
\begin{messagebox}
git am --resolved
\end{messagebox}

\subsection{回退到某个时间点}
当需要把\emphasizebox{git}仓库\emphasizebox{reset}到某个时间点，执行命令：
\begin{commandbox}
± git checkout 'master@{2020-07-22 12:44}'
\end{commandbox}
repo命令：
\begin{commandbox}
± repo forall -c git checkout 'master@{2020-07-15 12:44}'
\end{commandbox}

\subsection{GIT配置}
\item git全局配置，使用命令：
\begin{commandbox}
$ git config --global user.email "mozhiye@outlook.com" 
$ git config --global user.name "mozhiye"
$ git config --global alias.st "status"
$ git config --global alias.co "checkout"
$ git config --global core.editor vim
\end{commandbox}

\item 查看git全局配置，打开文件\emphasizebox{./gitconfig}
\begin{messagebox}
[user]
        email = mozhiye@outlook.com
        name = mozhiye
[alias]
        st = status
        co = checkout
[core]
        editor = vim
\end{messagebox}

\end{itemize}

%============================================
%                   TIG使用
%============================================
\subsection{tig使用}
输入 【 tig 】+ 【 Enter 】即可进入 tig 模式。此时展现在面前的将会是本地所有的 commit 记录以及分支的演化。

【 j 】【 k 】可上下切换选中的行，【 Enter 】可分屏查看当前 commit 记录详情，【 l 】小写的 L，全屏查看 commit 记录。

【 r 】进入 refs view 模式，查看所有分支，使用 【 j/k 】上下切换， 【 Enter 】查看分支演化。

【 s 】进入 status view，效果同 git status 命令，会展示所有 Untracked 和 UnStaged 文件。 选中 Unstaged 的文件键入【 u 】效果同 git add ，选中 staged 的文件键入

【 u 】效果同 git reset，即撤销 add 操作。【 Enter 】查看分屏查看当前文件的修改记录。

status view 模式下键入 【 C 】进入 vim 编辑器，【 i 】进入编辑模式，在第一行输入 commit 信息，【 :x 】退出并保存。【 m 】查看 commit 记录。

【 c 】进入 stash view 模式，全屏查看修改记录，可配合 【 s 】 使用。

【 t 】进入 tree view 模式，git 目录会以文件夹的形式展示。

【 Enter】进入子目录，【 , 】返回上一级目录。

【 m 】进入 main view 查看当前分支的所有 commit 记录，使用 【 j/k 】上下切换，

【 回车 】可分屏查看 commit 详情。同样，【 j/k 】上下移动，【空格】翻页。
main view 可以认为是主页。

【 / 】输入关键字可进行搜索。

【 R 】刷新当前页面，可退出搜索的高亮状态。

【 Q 】退出 tig。

【 h 】查看快捷键帮助。

\subsection{查看分支历史}
有时候需要查看分支的创建历史, 查看分支从哪个点分出来
\begin{commandbox}
 >  git reflog show --date=iso origin/case/T8_pro
\end{commandbox}

\begin{messagebox}
2ac407d refs/remotes/origin/case/T8_pro@{2021-01-20 08:50:29 +0800}: pull --rebase: fast-forward
b89c141 refs/remotes/origin/case/T8_pro@{2021-01-19 10:25:00 +0800}: pull --rebase: fast-forward
cc1b608 refs/remotes/origin/case/T8_pro@{2021-01-18 19:49:21 +0800}: pull --rebase: fast-forward
dc869be refs/remotes/origin/case/T8_pro@{2021-01-12 09:15:31 +0800}: pull --rebase: fast-forward
f252a8e refs/remotes/origin/case/T8_pro@{2021-01-08 09:04:55 +0800}: pull --rebase: fast-forward
e818850 refs/remotes/origin/case/T8_pro@{2021-01-04 17:30:59 +0800}: pull --rebase: fast-forward
58a7568 refs/remotes/origin/case/T8_pro@{2020-12-30 08:56:18 +0800}: pull --rebase: fast-forward
c06741c refs/remotes/origin/case/T8_pro@{2020-12-24 14:07:14 +0800}: pull --rebase: fast-forward
9c38ce4 refs/remotes/origin/case/T8_pro@{2020-12-15 11:00:33 +0800}: fetch origin: storing head
\end{messagebox}
由显示信息看到该命令只是显示本地对该分支的操作历史，只能大概定位时间点;


\subsection{cherry-pick合并某个提交}
使用场景: 在不同分支开发过程中，经常需要在某个分支上解决的bug合并到另外一些分支上, 这时需要将某个分支的提交合并到指定分支上去
\begin{itemize}
\item 把某个提交应用到当前分支上
\begin{commandbox}
 > git cherry-pick <commitHash>
\end{commandbox}

\item 把某个分支的最新提交应用到当前分支上
\begin{commandbox}
 > git cherry-pick branch-name
\end{commandbox}

\item 把多个提交应用到当前分支上
\begin{commandbox}
 > git cherry-pick <commitHash1> <commitHash2> <commitHash3>
\end{commandbox}

\item 把多个连续提交应用到当前分支上, commitHashBegin需要\emphasizebox{早于}commitEnd提交, 但\emphasizebox{不包含} \newline commitHashBegin的提交内容
\begin{commandbox}
 > git cherry-pick <commitHashBegin>..<commitHashEnd>
\end{commandbox}

\item 包含commitHashBegin的提交内容
\begin{commandbox}
 > git cherry-pick <commitHashBegin>^..<commitHashEnd>
\end{commandbox}

\end{itemize}
